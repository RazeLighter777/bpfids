use clap::{Command, Parser, Subcommand};
use serde::{Deserialize, Serialize};
use serde_json;
use std::net::{IpAddr, Ipv4Addr};
mod ids;
#[derive(Subcommand, Debug, Clone)]
enum Commands {
    Apply,
    List,
    Clear,
    DebugBuild,
    Build,
    PrintTestRuleSerialization,
}

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Path to the json configuration file
    #[arg(short, long, default_value = "config.json")]
    config: String,
    // Command
    #[command(subcommand)]
    cmd: Commands,
}
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();
    let config_content = std::fs::read_to_string(&args.config)
        .expect("Failed to read configuration file");
    let config: ids::Config = serde_json::from_str(&config_content)
        .expect("Failed to parse json configuration");
    match args.cmd {
        Commands::Apply => {
            println!("Applying configuration from {}", args.config);
            let config_content = std::fs::read_to_string(&args.config)
                .expect("Failed to read configuration file");
            let config: ids::Config = serde_json::from_str(&config_content)
                .expect("Failed to parse json configuration");
            println!("Parsed configuration: {:#?}", config);
            // Here you would add logic to apply the configuration, e.g., load BPF program
        }
        Commands::List => {
            for rule in &config.rules {
                println!("{:?}", rule);
            }
        }
        Commands::Clear => {
            println!("Clearing all rules (not implemented)");
            // Here you would add logic to clear all rules
        }
        Commands::DebugBuild => {
            // prints memoized combined c code to stdout
            let c_code = config.to_c_memoized();
            println!("Generated memoized C code:\n{}", c_code);
            // Here you would add logic to compile the C code into a BPF program
        }
        Commands::Build => {
            // open bpfidsrules.c and write the combined memoized c code to it
            match std::fs::File::create("bpfidsrules.c") {
                Ok(f) => {
                    let mut w = std::io::BufWriter::new(f);
                    // write warning that this file is autogenerated
                    writeln!(w, "/* This file is autogenerated. Do not edit directly. */").expect("Failed to write to bpfidsrules.c");
                    let code = config.to_c_memoized();
                    use std::io::Write;
                    writeln!(w, "{}", code).expect("Failed to write to bpfidsrules.c");
                    println!("Generated memoized bpfidsrules.c.");
                }
                Err(_) => eprintln!("Failed to create bpfidsrules.c"),
            }
            // run make to compile the bpf program
            let make_status = std::process::Command::new("make")
                .status()
                .expect("Failed to execute make");
            if make_status.success() {
                println!("Successfully built BPF program.");
            } else {
                eprintln!("Failed to build BPF program.");
            }
        }
        Commands::PrintTestRuleSerialization => {
            let test_rule = ids::IdsRule {
                action: ids::IdsAction::Alert,
                expr : ids::IdsExpr::And(Box::new(ids::IdsExpr::Match(ids::IdsMatch::DestinationHost(IpAddr::V4(Ipv4Addr::new(192, 168, 1, 1))))), Box::new(ids::IdsExpr::Match(ids::IdsMatch::SourceHost(IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1)))))),
                };
            let serialized = serde_json::to_string(&test_rule).unwrap();
            println!("Serialized test rule:\n{}", serialized);
            }


    }
    Ok(())
}
